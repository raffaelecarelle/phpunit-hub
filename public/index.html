<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHPUnit Hub</title>
    <link id="favicon" rel="icon" href="#">
    <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .filter-panel-dropdown { position: absolute; top: 100%; right: 0; z-index: 20; min-width: 350px; }
        .suite-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 4px; border-radius: 4px; transition: background-color 0.2s; }
        .suite-header:hover { background-color: #374151; } /* gray-700 */
        .suite-arrow { transition: transform 0.2s ease-in-out; margin-right: 8px; }
        .suite-arrow.rotated { transform: rotate(90deg); }
        .spinner { border: 2px solid #f3f3f3; border-top: 2px solid #3498db; border-radius: 50%; width: 14px; height: 14px; animation: spin 1s linear infinite; margin-left: 8px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .test-item { display: flex; justify-content: space-between; align-items: center; padding: 6px 4px; border-radius: 4px; transition: background-color 0.2s; }
        .test-item:hover { background-color: #374151; }
        .test-item-left { display: flex; align-items: center; }
        .status-icon { width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; flex-shrink: 0; }
        .status-neutral { background-color: #6b7280; }
        .status-passed { background-color: #10B981; }
        .status-failed, .status-errored { background-color: #EF4444; } /* Changed from .status-error to .status-errored */
        .status-running { background-color: #3498db; } /* New status color */
        .test-name { color: #d1d5db; }
        .test-time { font-size: 0.8em; color: #9ca3af; }
        /* Sort arrow animation */
        .sort-arrow { display: inline-block; transition: transform 220ms cubic-bezier(.4,0,.2,1), opacity 220ms ease; transform-origin: center; }
        .sort-arrow.none { opacity: 0.7; transform: rotate(0deg) scale(1); }
        .sort-arrow.asc { opacity: 1; transform: rotate(0deg) scale(1); }
        .sort-arrow.desc { opacity: 1; transform: rotate(180deg) scale(1); }
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937; /* bg-gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563; /* bg-gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* bg-gray-500 */
        }
        /* Custom Output Formatting - mostly removed, keeping for potential future use or if some raw output is desired */
        .output-line {
            padding: 2px 8px;
            margin: 0 -8px; /* Counteract padding to align with container */
        }
        .summary-ok {
            background-color: rgba(16, 185, 129, 0.2); /* bg-green-500 with opacity */
            border-left: 4px solid #10B981;
            font-weight: bold;
        }
        .summary-fail {
            background-color: rgba(239, 68, 68, 0.2); /* bg-red-500 with opacity */
            border-left: 4px solid #EF4444;
            font-weight: bold;
        }
        .summary-warn {
            background-color: rgba(245, 158, 11, 0.2); /* bg-amber-500 with opacity */
            border-left: 4px solid #F59E0B;
            font-weight: bold;
        }
        .summary-time {
            background-color: #374151; /* bg-gray-700 */
            margin-top: 8px;
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 4px;
        }
        .failure-block {
            background-color: rgba(239, 68, 68, 0.05);
            border-left: 4px solid #b91c1c; /* red-800 */
            padding-top: 8px;
            padding-bottom: 8px;
            margin-bottom: 8px;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-300 font-sans">
<div id="app" class="flex flex-col h-screen">
    <header class="bg-gray-800 shadow-md p-4 flex justify-between items-center z-10 relative">
        <h1 class="text-2xl font-bold text-white">PHPUnit Hub</h1>
        <div class="flex items-center space-x-4">
            <div class="relative">
                <button @click="toggleFilterPanel" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out">
                    Filters
                </button>
                <div v-show="showFilterPanel" @click.stop class="filter-panel-dropdown bg-gray-800 p-4 rounded-lg shadow-lg border border-gray-700">
                    <h3 class="text-md font-semibold text-white mb-3">Advanced Filters</h3>
                    <div class="form-group mb-4">
                        <label for="group-filter" class="block text-sm font-medium text-gray-300 mb-1">Test Groups</label>
                        <select id="group-filter" v-model="selectedGroups" multiple
                                class="w-full bg-gray-700 border border-gray-600 rounded py-2 px-3 text-white h-24">
                            <option v-for="(group, key) in availableGroups" :value="key">{{ group }}</option>
                        </select>
                    </div>
                    <div class="form-group mb-4">
                        <label for="filter-suite" class="block text-sm font-medium text-gray-300 mb-1">Test Suites</label>
                        <select id="filter-suite" v-model="selectedSuites" multiple
                                class="w-full bg-gray-700 border border-gray-600 rounded py-2 px-3 text-white h-24">
                            <option v-for="(suite, key) in availableSuites" :value="key">{{ suite }}</option>
                        </select>
                    </div>
                    <div class="form-group mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Output Options</label>
                        <div class="space-y-2">
                            <label class="flex items-center text-sm"><input type="checkbox" v-model="options.displayWarnings" class="mr-2"> Show Warnings</label>
                            <label class="flex items-center text-sm"><input type="checkbox" v-model="options.displayDeprecations" class="mr-2"> Show Deprecations</label>
                            <label class="flex items-center text-sm"><input type="checkbox" v-model="options.displaySkipped" class="mr-2"> Show Skipped</label>
                            <label class="flex items-center text-sm"><input type="checkbox" v-model="options.displayIncomplete" class="mr-2"> Show Incomplete</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Stop On Options</label>
                        <div class="grid grid-cols-2 gap-2">
                            <label class="flex items-center text-sm"><input type="checkbox" v-model="options.stopOnDefect" class="mr-2"> Defect</label>
                            <label class="flex items-center text-sm"><input type="checkbox" v-model="options.stopOnError" class="mr-2"> Error</label>
                            <label class="flex items-center text-sm"><input type="checkbox" v-model="options.stopOnFailure" class="mr-2"> Failure</label>
                            <label class="flex items-center text-sm"><input type="checkbox" v-model="options.stopOnWarning" class="mr-2"> Warning</label>
                        </div>
                    </div>
                </div>
            </div>
            <button @click="runFailedTests" :disabled="isAnyTestRunning || !hasFailedTests" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out disabled:bg-gray-500">
                Run Failed
            </button>
            <button @click="togglePlayStop" :title="isAnyTestRunning ? 'Stop all test runs' : 'Run all tests'" :disabled="isAnyStopPending" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out disabled:opacity-60">
                <span v-if="isAnyStopPending">Stopping...</span>
                <template v-else>
                    <span v-if="!isAnyTestRunning">
                        <!-- Play icon -->
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5 inline-block">
                            <path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z" />
                        </svg>
                        <span class="ml-2 align-middle">Run All</span>
                    </span>
                    <span v-else>
                        <!-- Stop icon -->
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5 inline-block">
                            <path d="M6 6h8v8H6z" />
                        </svg>
                        <span class="ml-2 align-middle">Stop All</span>
                    </span>
                </template>
            </button>
        </div>
    </header>

    <div class="flex flex-grow overflow-hidden">
        <!-- Test Explorer Sidebar -->
        <aside id="test-sidebar" class="bg-gray-800 p-4 overflow-y-auto border-r border-gray-700">
            <input type="text" v-model="searchQuery" placeholder="Search tests..."
                   class="w-full bg-gray-700 border border-gray-600 rounded py-2 px-3 mb-4 text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
            <div v-if="filteredTestSuites.length === 0" class="text-gray-500">No tests found.</div>
            <div v-for="suite in filteredTestSuites" :key="suite.id" class="mb-4">
                <div class="suite-header text-md text-gray-200">
                    <div @click="toggleSuite(suite.id)" class="flex items-center flex-grow cursor-pointer">
                        <svg class="suite-arrow w-4 h-4 text-gray-400" :class="{ 'rotated': expandedSuites.has(suite.id) }" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                        <span class="font-bold">{{ suite.name }}</span>
                    </div>
                    <div class="flex items-center">
                        <div v-if="suite.runId && isTestRunning(suite.runId)" class="spinner !w-4 !h-4"></div>
                        <span v-if="suite.runId && isTestRunning(suite.runId)" @click.stop="stopSingleTest(suite.runId)" class="cursor-pointer text-red-500 hover:text-red-400 ml-2" title="Stop this suite">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5"><path d="M6 6h8v8H6z" /></svg>
                        </span>
                        <span v-else @click.stop="runSuiteTests(suite.id)" :class="{'cursor-pointer text-green-500 hover:text-green-400': !isTestStopPending(suite.runId), 'text-gray-500': isTestStopPending(suite.runId)}" :title="isTestStopPending(suite.runId) ? 'Stopping...' : 'Run all tests in this suite'">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5"><path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z" /></svg>
                        </span>
                    </div>
                </div>
                <ul v-show="expandedSuites.has(suite.id)" class="ml-2 mt-2 space-y-1">
                    <li v-for="method in suite.methods" :key="method.id" class="test-item">
                        <div class="test-item-left w-full">
                            <span class="status-icon" :class="method.status ? `status-${method.status}` : 'status-neutral'"></span>
                            <div class="flex items-center space-x-2 justify-between w-full">
                                <span class="test-name">{{ method.name }}</span>
                                <div class="flex items-center">
                                    <div v-if="method.runId && isTestRunning(method.runId)" class="spinner !w-4 !h-4"></div>
                                    <span v-if="method.runId && isTestRunning(method.runId)" @click.stop="stopSingleTest(method.runId)" class="cursor-pointer text-red-500 hover:text-red-400 ml-2" title="Stop this test">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4"><path d="M6 6h8v8H6z" /></svg>
                                    </span>
                                    <span v-else @click.stop="runSingleTest(method.id)" :class="{'cursor-pointer text-green-500 hover:text-green-400': !isTestStopPending(method.runId), 'text-gray-500': isTestStopPending(method.runId)}" :title="isTestStopPending(method.runId) ? 'Stopping...' : 'Run this test'">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4"><path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z" /></svg>
                                    </span>
                                </div>
                            </div>
                        </div>
                    </li>
                </ul>
            </div>
        </aside>

        <div id="resizer" class="w-1.5 cursor-col-resize bg-gray-700 hover:bg-blue-600 transition-colors duration-200"></div>

        <!-- Main Content -->
        <main id="main-content" class="flex-1 p-4 flex flex-col">
            <div class="flex-shrink-0 border-b border-gray-700">
                <nav class="-mb-px flex space-x-4">
                    <button @click="activeTab = 'results'" :class="['whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm', activeTab === 'results' ? 'border-blue-500 text-blue-400' : 'border-transparent text-gray-500 hover:text-gray-300 hover:border-gray-400']">
                        Results
                    </button>
                    <!-- Removed Output Tab -->
                </nav>
            </div>
            <div class="flex-grow overflow-y-auto pt-4">
                <div v-show="activeTab === 'results'">
                    <div v-if="!results" class="text-gray-500 text-center pt-10">Run tests to see the results.</div>
                    <div v-else class="space-y-2">
                        <!-- Execution Summary -->
                        <div class="bg-gray-800 rounded-lg shadow-lg p-4">
                            <div class="grid grid-cols-3 gap-4 text-center mb-4 border-b border-gray-700 pb-4">
                                <div>
                                    <div class="text-sm text-gray-400">Total Tests</div>
                                    <div class="text-2xl font-bold">{{ results.summary.tests }}</div>
                                </div>
                                <div>
                                    <div class="text-sm text-gray-400">Total Assertions</div>
                                    <div class="text-2xl font-bold">{{ results.summary.assertions }}</div>
                                </div>
                                <div>
                                    <div class="text-sm text-gray-400">Duration</div>
                                    <div class="text-2xl font-bold">{{ results.summary.time.toFixed(2) }}s</div>
                                </div>
                            </div>
                            <div class="flex justify-center flex-wrap gap-x-4 gap-y-2 text-sm">
                                <span class="flex items-center"><span class="w-2 h-2 rounded-full bg-green-500 mr-2"></span>{{ statusCounts.passed }} Passed</span>
                                <span v-if="statusCounts.failed > 0" class="flex items-center"><span class="w-2 h-2 rounded-full bg-red-500 mr-2"></span>{{ statusCounts.failed }} Failed</span>
                                <span v-if="statusCounts.error > 0" class="flex items-center"><span class="w-2 h-2 rounded-full bg-red-500 mr-2"></span>{{ statusCounts.error }} Errors</span>
                                <span v-if="options.displayWarnings && statusCounts.warnings > 0" class="flex items-center"><span class="w-2 h-2 rounded-full bg-amber-500 mr-2"></span>{{ statusCounts.warnings }} Warnings</span>
                                <span v-if="statusCounts.skipped > 0" class="flex items-center"><span class="w-2 h-2 rounded-full bg-gray-500 mr-2"></span>{{ statusCounts.skipped }} Skipped</span>
                                <span v-if="options.displayDeprecations && statusCounts.deprecations > 0" class="flex items-center"><span class="w-2 h-2 rounded-full bg-purple-500 mr-2"></span>{{ statusCounts.deprecations }} Deprecations</span>
                            </div>
                        </div>

                        <!-- Grouped Test Results -->
                        <div v-for="group in groupedResults" :key="group.className" class="bg-gray-800 rounded-lg shadow-lg overflow-hidden">
                            <!-- TestCase Group Header -->
                            <div @click="toggleTestcaseGroup(group.className)" class="flex items-center justify-between bg-gray-700 px-4 py-2 cursor-pointer hover:bg-gray-600">
                                <div class="flex items-center">
                                    <svg class="w-5 h-5 mr-2 text-gray-400 transition-transform" :class="{ 'rotate-90': expandedTestcaseGroups.has(group.className) }" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" /></svg>
                                    <span class="font-bold text-white">{{ group.className }}</span>
                                </div>
                                <div class="flex items-center space-x-4 text-sm">
                                    <span v-if="group.failed > 0" class="px-2 py-0.5 rounded-full bg-red-900 text-red-300">{{ group.failed }} Failed</span>
                                    <span v-if="group.errored > 0" class="px-2 py-0.5 rounded-full bg-red-900 text-red-300">{{ group.errored }} Error</span>
                                    <span v-if="group.warning > 0 && options.displayWarnings" class="px-2 py-0.5 rounded-full bg-amber-800 text-amber-200">{{ group.warning }} Warnings</span>
                                    <span v-if="group.deprecation > 0 && options.displayDeprecations" class="px-2 py-0.5 rounded-full bg-purple-800 text-purple-200">{{ group.deprecation }} Deprecations</span>
                                    <span v-if="group.passed > 0" class="px-2 py-0.5 rounded-full bg-green-900 text-green-300">{{ group.passed }} Passed</span>
                                </div>
                            </div>

                            <!-- Testcases for this group -->
                            <div v-show="expandedTestcaseGroups.has(group.className)" class="divide-y divide-gray-700">
                                <!-- Problematic tests (non-passed) -->
                                <template v-for="testcase in group.testcases.filter(t => t.status !== 'passed')">
                                    <div @click="toggleDetails(testcase)" class="flex items-center p-3 cursor-pointer hover:bg-gray-700/[.5]">
                                        <div class="w-28 flex-shrink-0 pl-3">
                                            <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full" :class="statusClass(testcase.status)">{{ testcase.status }}</span>
                                        </div>
                                        <div class="flex-grow">
                                            <div class="text-sm text-white">{{ testcase.name }}</div>
                                        </div>
                                        <div class="w-28 text-right flex-shrink-0 pr-3">
                                            <span class="text-sm text-gray-400">{{ testcase.time.toFixed(4) }}s</span>
                                        </div>
                                    </div>
                                    <div v-if="isExpanded(testcase)" class="bg-gray-900 p-4">
                                        <h4 class="font-bold text-md mb-2" :class="{'text-red-400': testcase.status === 'failed' || testcase.status === 'errored'}">{{ testcase.message }}</h4>
                                        <pre v-if="testcase.trace" class="font-mono text-sm text-white whitespace-pre-wrap bg-black p-3 rounded">{{ testcase.trace }}</pre>
                                    </div>
                                </template>
                                <!-- Passed tests with warnings/deprecations (if filters are enabled) -->
                                <template v-for="testcase in group.testcases.filter(t => t.status === 'passed' && ((options.displayWarnings && t.warnings?.length > 0) || (options.displayDeprecations && t.deprecations?.length > 0)))">
                                    <div @click="toggleDetails(testcase)" class="flex items-center p-3 cursor-pointer hover:bg-gray-700/[.5]">
                                        <div class="w-28 flex-shrink-0 pl-3">
                                            <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-900 text-green-300">passed</span>
                                        </div>
                                        <div class="flex-grow">
                                            <div class="text-sm text-white">{{ testcase.name }}</div>
                                            <div class="text-xs text-gray-400 mt-1">
                                                <span v-if="options.displayWarnings && testcase.warnings?.length > 0" class="text-amber-400">⚠ {{ testcase.warnings.length }} warning(s)</span>
                                                <span v-if="options.displayDeprecations && testcase.deprecations?.length > 0" class="text-purple-400 ml-2">⚠ {{ testcase.deprecations.length }} deprecation(s)</span>
                                            </div>
                                        </div>
                                        <div class="w-28 text-right flex-shrink-0 pr-3">
                                            <span class="text-sm text-gray-400">{{ testcase.time.toFixed(4) }}s</span>
                                        </div>
                                    </div>
                                    <div v-if="isExpanded(testcase)" class="bg-gray-900 p-4 space-y-3">
                                        <div v-if="options.displayWarnings && testcase.warnings?.length > 0">
                                            <h5 class="font-bold text-sm text-amber-400 mb-2">Warnings ({{ testcase.warnings.length }})</h5>
                                            <div v-for="(warning, idx) in testcase.warnings" :key="'w-'+idx" class="bg-amber-900/20 border-l-4 border-amber-500 p-2 mb-2">
                                                <pre class="font-mono text-xs text-gray-300 whitespace-pre-wrap">{{ warning }}</pre>
                                            </div>
                                        </div>
                                        <div v-if="options.displayDeprecations && testcase.deprecations?.length > 0">
                                            <h5 class="font-bold text-sm text-purple-400 mb-2">Deprecations ({{ testcase.deprecations.length }})</h5>
                                            <div v-for="(deprecation, idx) in testcase.deprecations" :key="'d-'+idx" class="bg-purple-900/20 border-l-4 border-purple-500 p-2 mb-2">
                                                <pre class="font-mono text-xs text-gray-300 whitespace-pre-wrap">{{ deprecation }}</pre>
                                            </div>
                                        </div>
                                    </div>
                                </template>
                                <!-- Passed tests summary (only those without warnings/deprecations or with filters disabled) -->
                                <div v-if="group.passed > 0" class="flex items-center p-3">
                                    <div class="w-28 flex-shrink-0 pl-3">
                                        <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-900 text-green-300">passed</span>
                                    </div>
                                    <div class="flex-grow">
                                        <div class="text-sm text-gray-400">{{ group.passed }} test(s) passed</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Removed Output Tab Content -->
            </div>
        </main>
    </div>
</div>

<script>
    const { createApp, ref, reactive, onMounted, computed } = Vue

    createApp({
        setup() {
            const runningTestIds = reactive({});
            const stopPending = reactive({});

            const activeTab = ref('results'); // Will always be 'results' now
            // const output = ref([]); // Removed
            // const results = ref(null); // Now a computed property
            const searchQuery = ref('');
            const testSuites = ref([]); // For the sidebar, will be updated by realtime events
            const availableSuites = ref([]);
            const selectedSuites = ref([]);
            const availableGroups = ref([]);
            const selectedGroups = ref([]);
            const options = reactive({
                displayWarnings: true,
                displayDeprecations: true,
                displaySkipped: true,
                displayIncomplete: true,
                stopOnDefect: false,
                stopOnError: false,
                stopOnFailure: false,
                stopOnWarning: false,
            });
            const showFilterPanel = ref(false);
            const expandedSuites = ref(new Set());
            const expandedTestId = ref(null);
            const expandedTestcaseGroups = ref(new Set());
            let ws = null;

            // New reactive state for real-time test runs
            const realtimeTestRuns = reactive({}); // Keyed by runId, stores detailed real-time data
            const lastCompletedRunId = ref(null); // To track which run's results to display

            const favicons = {
                neutral: `<svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="14" fill="#6b7280"/></svg>`,
                success: `<svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="14" fill="#10B981"/><polyline points="9 16, 14 21, 23 12" stroke="white" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
                failure: `<svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="16" fill="#EF4444"/><line x1="11" y1="11" x2="21" y2="21" stroke="white" stroke-width="3" stroke-linecap="round"/><line x1="21" y1="11" x2="11" y2="21" stroke="white" stroke-width="3" stroke-linecap="round"/></svg>`
            };

            const results = computed(() => {
                // Show results from the last started or completed run
                const runId = lastCompletedRunId.value || Object.keys(realtimeTestRuns).pop();
                if (!runId || !realtimeTestRuns[runId]) {
                    return null;
                }
                const run = realtimeTestRuns[runId];

                // Calculate summary dynamically from the test results if not yet available
                const summary = run.summary || {
                    numberOfTests: 0,
                    numberOfAssertions: 0,
                    duration: 0,
                    numberOfFailures: 0,
                    numberOfErrors: 0,
                    numberOfWarnings: 0,
                    numberOfSkipped: 0,
                    numberOfDeprecations: 0,
                    numberOfIncomplete: 0,
                };

                // Transform the real-time run data into a structure similar to the old JUnitParser output
                // This makes it easier to reuse existing statusCounts and groupedResults logic
                const transformedSuites = [];
                for (const suiteName in run.suites) {
                    const suiteData = run.suites[suiteName];
                    const testcases = [];
                    for (const testId in suiteData.tests) {
                        const testData = suiteData.tests[testId];
                        testcases.push({
                            name: testData.name,
                            class: testData.class,
                            id: testData.id, // Keep id for easier lookup
                            time: testData.time || 0,
                            status: testData.status,
                            message: testData.message, // Store raw message for display
                            trace: testData.trace, // Store raw trace for display
                            warnings: testData.warnings || [], // Include warnings
                            deprecations: testData.deprecations || [], // Include deprecations
                        });
                    }
                    transformedSuites.push({
                        name: suiteData.name,
                        testcases: testcases,
                        // Add other suite-level summaries if needed, though groupedResults will calculate
                    });
                }

                // If no summary yet, calculate it from the current test data
                if (!run.summary) {
                    let totalTests = 0;
                    let totalDuration = 0;
                    for (const suiteName in run.suites) {
                        const suiteData = run.suites[suiteName];
                        totalTests += Object.keys(suiteData.tests).length;
                        for (const testId in suiteData.tests) {
                            const testData = suiteData.tests[testId];
                            totalDuration = Math.max(totalDuration, testData.time || 0);
                        }
                    }
                    summary.numberOfTests = totalTests;
                    summary.duration = totalDuration;
                    // Calculate failures, errors, etc. from suite counts
                    for (const suiteName in run.suites) {
                        const suiteData = run.suites[suiteName];
                        summary.numberOfFailures += suiteData.failed || 0;
                        summary.numberOfErrors += suiteData.errored || 0;
                        summary.numberOfWarnings += suiteData.warning || 0;
                        summary.numberOfSkipped += suiteData.skipped || 0;
                        summary.numberOfDeprecations += suiteData.deprecation || 0;
                        summary.numberOfIncomplete += suiteData.incomplete || 0;
                    }
                }

                return {
                    summary: {
                        tests: summary.numberOfTests,
                        assertions: summary.numberOfAssertions,
                        time: summary.duration,
                        failures: summary.numberOfFailures,
                        errors: summary.numberOfErrors,
                        warnings: summary.numberOfWarnings,
                        skipped: summary.numberOfSkipped,
                        deprecations: summary.numberOfDeprecations,
                        incomplete: summary.numberOfIncomplete,
                    },
                    suites: transformedSuites,
                };
            });

            const statusCounts = computed(() => {
                const counts = { passed: 0, failed: 0, error: 0, warnings: 0, skipped: 0, deprecations: 0, incomplete: 0 };
                if (!results.value || !results.value.summary) return counts;

                const s = results.value.summary;
                counts.failed = s.failures || 0;
                counts.error = s.errors || 0;
                counts.warnings = s.warnings || 0;
                counts.skipped = s.skipped || 0;
                counts.deprecations = s.deprecations || 0;
                counts.incomplete = s.incomplete || 0;

                // Calculate passed from total - problems
                const problems = counts.failed + counts.error + counts.warnings + counts.skipped + counts.incomplete + counts.deprecations;
                counts.passed = (s.tests || 0) - problems;

                return counts;
            });

            const hasFailedTests = computed(() => {
                if (!lastCompletedRunId.value || !realtimeTestRuns[lastCompletedRunId.value]) {
                    return false;
                }
                const run = realtimeTestRuns[lastCompletedRunId.value];
                return run.failedTestIds.size > 0;
            });

            const filteredTestSuites = computed(() => {
                if (!searchQuery.value) return testSuites.value;
                const lower = searchQuery.value.toLowerCase();
                return testSuites.value.map(suite => {
                    const methods = suite.methods.filter(m => m.name.toLowerCase().includes(lower));
                    if (suite.name.toLowerCase().includes(lower)) {
                        return { ...suite, methods: suite.methods };
                    }
                    if (methods.length > 0) {
                        return { ...suite, methods };
                    }
                    return null;
                }).filter(Boolean);
            });

            const isAnyTestRunning = computed(() => Object.keys(runningTestIds).length > 0);
            const isAnyStopPending = computed(() => Object.keys(stopPending).length > 0);

            const updateFavicon = (status = 'neutral') => {
                const favicon = document.getElementById('favicon');
                if (favicon) {
                    const svg = favicons[status] || favicons.neutral;
                    const dataUri = `data:image/svg+xml;base64,${btoa(svg)}`;
                    favicon.href = dataUri;
                }
            };

            const toggleFilterPanel = () => { showFilterPanel.value = !showFilterPanel.value; };
            const toggleSuite = (suiteId) => {
                if (expandedSuites.value.has(suiteId)) expandedSuites.value.delete(suiteId);
                else expandedSuites.value.add(suiteId);
            };
            const toggleDetails = (testcase) => {
                // Allow expanding any non-passed test, or passed tests with warnings/deprecations
                if (testcase.status === 'passed' && !testcase.warnings?.length && !testcase.deprecations?.length) return;
                const id = `${testcase.class}::${testcase.name}`;
                expandedTestId.value = expandedTestId.value === id ? null : id;
            };
            const isExpanded = (testcase) => `${testcase.class}::${testcase.name}` === expandedTestId.value;

            const toggleTestcaseGroup = (className) => {
                const newSet = new Set(expandedTestcaseGroups.value);
                if (newSet.has(className)) {
                    newSet.delete(className);
                } else {
                    newSet.add(className);
                }
                expandedTestcaseGroups.value = newSet;
            };

            const statusClass = (status) => {
                status = status || 'passed';
                return {
                    'bg-green-900 text-green-300': status === 'passed',
                    'bg-red-900 text-red-300': status === 'failed',
                    'bg-red-900 text-red-300 ': status === 'errored', // Changed from error
                    'bg-amber-800 text-amber-200': status === 'warning' || status === 'deprecation',
                    'bg-gray-700 text-gray-300': status === 'skipped' || status === 'incomplete',
                    'bg-blue-800 text-blue-300': status === 'running', // New status class
                };
            };

            const isTestRunning = (runId) => runningTestIds[runId] === true;
            const isTestStopPending = (runId) => stopPending[runId] === true;

            const runSingleTest = (testId) => runTests({ filters: [testId], contextId: testId });
            const runSuiteTests = (suiteId) => runTests({ filters: [suiteId], contextId: suiteId });
            const runAllTests = () => runTests({ filters: searchQuery.value ? [searchQuery.value] : [], contextId: 'global' });
            const runFailedTests = () => {
                if (!lastCompletedRunId.value || !realtimeTestRuns[lastCompletedRunId.value]) {
                    console.warn('No completed run to get failed tests from.');
                    return;
                }
                const failedTestIds = Array.from(realtimeTestRuns[lastCompletedRunId.value].failedTestIds);
                if (failedTestIds.length === 0) {
                    console.log('No failed tests to run.');
                    return;
                }
                runTests({ filters: failedTestIds, contextId: 'failed' });
            };

            const stopSingleTest = async (runId) => {
                stopPending[runId] = true;
                try {
                    const res = await fetch(`/api/stop-single-test/${runId}`, { method: 'POST' });
                    if (!res.ok) {
                        const text = await res.text();
                        console.error(`Failed to stop test run ${runId}: ${text}`);
                        delete stopPending[runId];
                    } else {
                        console.log(`Stop requested for test run ${runId}...`);
                    }
                } catch (e) {
                    console.error(`Failed to send stop request for ${runId}: ${e.message}`);
                    delete stopPending[runId];
                }
            };

            const stopTests = async () => {
                Object.keys(runningTestIds).forEach(runId => { stopPending[runId] = true; });
                try {
                    const res = await fetch('/api/stop', { method: 'POST' });
                    if (!res.ok) {
                        const text = await res.text();
                        console.error(`Failed to stop all tests: ${text}`);
                        Object.keys(runningTestIds).forEach(runId => { delete stopPending[runId]; });
                    } else {
                        console.log(`Stop requested for all tests...`);
                    }
                } catch (e) {
                    console.error(`Failed to send stop all request: ${e.message}`);
                    Object.keys(runningTestIds).forEach(runId => { delete stopPending[runId]; });
                }
            };

            const togglePlayStop = () => {
                if (isAnyTestRunning.value) stopTests();
                else runAllTests();
            };

            const fetchTests = async () => {
                try {
                    const response = await fetch('/api/tests');
                    const data = await response.json();
                    data.suites.forEach(suite => {
                        suite.runId = null;
                        suite.methods.forEach(method => {
                            method.time = null;
                            method.status = null;
                            method.runId = null;
                        });
                    });
                    testSuites.value = data.suites;
                    if(data.availableSuites) availableSuites.value = data.availableSuites;
                    if(data.availableGroups) availableGroups.value = data.availableGroups;
                } catch (e) { console.error("Failed to fetch tests:", e); }
            };

            const connectWebSocket = () => {
                ws = new WebSocket('ws://127.0.0.1:8080/ws/status');
                ws.onmessage = (event) => handleWebSocketMessage(JSON.parse(event.data));
                ws.onclose = () => {
                    Object.keys(runningTestIds).forEach(k => delete runningTestIds[k]);
                    Object.keys(stopPending).forEach(k => delete stopPending[k]);
                    updateFavicon('neutral');
                    console.log('WebSocket disconnected.');
                };
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
                ws.onopen = () => {
                    console.log('WebSocket connected.');
                };
            };

            const handleRealtimeEvent = (runId, eventData) => {
                let run = realtimeTestRuns[runId];
                if (!run) {
                    console.warn(`Received event for unknown runId: ${runId}. Initializing.`);
                    run = realtimeTestRuns[runId] = {
                        status: 'running',
                        contextId: 'unknown', // Will be updated by 'start' message
                        suites: {}, // Keyed by suite name, e.g., 'App\\Tests\\Unit\\MyTestSuite'
                        summary: null, // Populated by 'execution.ended'
                        failedTestIds: reactive(new Set()), // To track failed tests for 'run failed'
                    };
                }

                switch (eventData.event) {
                    case 'suite.started':
                        run.suites[eventData.data.name] = reactive({
                            name: eventData.data.name,
                            count: eventData.data.count,
                            tests: {}, // Keyed by test ID, e.g., 'App\\Tests\\Unit\\MyTestSuite::testMethod'
                            passed: 0, failed: 0, errored: 0, skipped: 0, incomplete: 0, warning: 0, deprecation: 0, risky: 0,
                            hasIssues: false,
                        });
                        break;
                    case 'test.prepared':
                        const testIdParts = eventData.data.test.split('::');
                        const suiteName = testIdParts[0]; // Assuming testId is like 'SuiteName::testMethod'
                        // Initialize suite if it doesn't exist yet
                        if (!run.suites[suiteName]) {
                            run.suites[suiteName] = reactive({
                                name: suiteName,
                                count: 0,
                                tests: {},
                                passed: 0, failed: 0, errored: 0, skipped: 0, incomplete: 0, warning: 0, deprecation: 0, risky: 0,
                                hasIssues: false,
                            });
                        }
                        run.suites[suiteName].tests[eventData.data.test] = reactive({
                            id: eventData.data.test,
                            name: testIdParts[1],
                            class: suiteName,
                            status: 'running', // Or 'prepared'
                            time: null,
                            message: null,
                            trace: null,
                            warnings: [], // Array of warning messages
                            deprecations: [], // Array of deprecation messages
                        });
                        // Also update the sidebar test status
                        testSuites.value.forEach(s => {
                            if (s.id === suiteName) { // Assuming suite.id is the full class name
                                s.methods.forEach(m => {
                                    if (m.id === eventData.data.test) {
                                        m.status = 'running';
                                        m.runId = runId; // Link sidebar test to this run
                                    }
                                });
                            }
                        });
                        break;
                    case 'test.warning':
                    case 'test.deprecation':
                        const warningDeprecationTestId = eventData.data.test;
                        const warningDeprecationTestIdParts = warningDeprecationTestId.split('::');
                        const warningDeprecationSuiteName = warningDeprecationTestIdParts[0];

                        if (run.suites[warningDeprecationSuiteName] && run.suites[warningDeprecationSuiteName].tests[warningDeprecationTestId]) {
                            const test = run.suites[warningDeprecationSuiteName].tests[warningDeprecationTestId];
                            const suite = run.suites[warningDeprecationSuiteName];

                            // Add warning/deprecation to the test's list
                            if (eventData.event === 'test.warning') {
                                test.warnings.push(eventData.data.message || 'Warning triggered');
                                suite.warning++;
                            } else if (eventData.event === 'test.deprecation') {
                                test.deprecations.push(eventData.data.message || 'Deprecation triggered');
                                suite.deprecation++;
                            }

                            suite.hasIssues = true;
                        }
                        break;
                    case 'test.passed':
                    case 'test.failed':
                    case 'test.errored':
                    case 'test.skipped':
                    case 'test.incomplete':
                        const testId = eventData.data.test;
                        const testIdPartsForUpdate = testId.split('::');
                        const testSuiteNameForUpdate = testIdPartsForUpdate[0];

                        if (run.suites[testSuiteNameForUpdate] && run.suites[testSuiteNameForUpdate].tests[testId]) {
                            const test = run.suites[testSuiteNameForUpdate].tests[testId];
                            test.status = eventData.event.replace('test.', ''); // 'passed', 'failed', etc.
                            test.time = eventData.data.time;
                            test.message = eventData.data.message || null;
                            test.trace = eventData.data.trace || null;

                            // Update suite counts and hasIssues
                            const suite = run.suites[testSuiteNameForUpdate];

                            if (suite[test.status] !== undefined) {
                                suite[test.status]++;
                            }
                            if (test.status !== 'passed') {
                                suite.hasIssues = true;
                                if (test.status === 'failed' || test.status === 'errored') {
                                    run.failedTestIds.add(testId);
                                }
                            } else {
                                run.failedTestIds.delete(testId); // If a previously failed test now passes
                            }

                            // Update sidebar test status
                            testSuites.value.forEach(s => {
                                if (s.id === testSuiteNameForUpdate) {
                                    s.methods.forEach(m => {
                                        if (m.id === testId) {
                                            m.status = test.status;
                                            m.time = test.time;
                                        }
                                    });
                                }
                            });
                        }
                        break;
                    case 'suite.finished':
                        // The summary for the suite is already updated in the suite.started object
                        break;
                    case 'execution.ended':
                        run.summary = eventData.data.summary;
                        lastCompletedRunId.value = runId; // Mark this run as the one to display
                        break;
                }
            };

            const handleWebSocketMessage = (message) => {
                switch (message.type) {
                    case 'start':
                        // Initialize a new run in realtimeTestRuns
                        realtimeTestRuns[message.runId] = reactive({
                            status: 'running',
                            contextId: message.contextId,
                            suites: {},
                            summary: null,
                            failedTestIds: reactive(new Set()),
                        });
                        runningTestIds[message.runId] = true;
                        delete stopPending[message.runId];
                        // Update sidebar for the specific run context
                        if (message.contextId) {
                            testSuites.value.forEach(suite => {
                                if (suite.id === message.contextId) suite.runId = message.runId;
                                suite.methods.forEach(method => {
                                    if (method.id === message.contextId) method.runId = message.runId;
                                });
                            });
                        }
                        updateFavicon('neutral'); // Reset favicon
                        // Clear previous results if this is a new global run
                        if (message.contextId === 'global' || message.contextId === 'failed') { // Also clear for 'run failed'
                            expandedTestId.value = null;
                            expandedTestcaseGroups.value = new Set();
                            // Reset all test statuses in sidebar
                            testSuites.value.forEach(s => s.methods.forEach(m => { m.time = null; m.status = null; m.runId = null; }));
                        }
                        // Show results immediately when a run starts
                        activeTab.value = 'results';
                        break;

                    case 'realtime':
                        try {
                            const realtimeEvent = JSON.parse(message.data);
                            handleRealtimeEvent(message.runId, realtimeEvent);
                        } catch (e) {
                            console.error('Failed to parse realtime event data:', e, message.data);
                        }
                        break;

                    case 'exit':
                        if (realtimeTestRuns[message.runId]) {
                            realtimeTestRuns[message.runId].status = 'finished';
                        }
                        delete runningTestIds[message.runId];
                        delete stopPending[message.runId];

                        // Update sidebar runId for the specific run context
                        if (realtimeTestRuns[message.runId] && realtimeTestRuns[message.runId].contextId) {
                            testSuites.value.forEach(suite => {
                                if (suite.runId === message.runId) suite.runId = null;
                                suite.methods.forEach(method => {
                                    if (method.runId === message.runId) method.runId = null;
                                });
                            });
                        }

                        // If this was the last running test, update favicon based on its summary
                        if (Object.keys(runningTestIds).length === 0) {
                            const summary = realtimeTestRuns[message.runId]?.summary;
                            if (summary && (summary.numberOfFailures > 0 || summary.numberOfErrors > 0)) {
                                updateFavicon('failure');
                            } else if (summary) {
                                updateFavicon('success');
                            } else {
                                updateFavicon('neutral');
                            }
                        }
                        // Ensure the results displayed are from the last completed run
                        // This is handled by lastCompletedRunId.value being set in handleRealtimeEvent for 'execution.ended'
                        break;

                    case 'stopped':
                        if (realtimeTestRuns[message.runId]) {
                            realtimeTestRuns[message.runId].status = 'stopped';
                        }
                        delete runningTestIds[message.runId];
                        delete stopPending[message.runId];
                        // Update sidebar runId for the specific run context
                        if (realtimeTestRuns[message.runId] && realtimeTestRuns[message.runId].contextId) {
                            testSuites.value.forEach(suite => {
                                if (suite.runId === message.runId) suite.runId = null;
                                suite.methods.forEach(method => {
                                    if (method.runId === message.runId) method.runId = null;
                                });
                            });
                        }
                        if (Object.keys(runningTestIds).length === 0) updateFavicon('neutral');
                        break;
                }
            };

            const groupedResults = computed(() => {
                if (!results.value) return [];

                const groups = {};

                results.value.suites.forEach(suite => {
                    suite.testcases.forEach(tc => {
                        if (!groups[tc.class]) {
                            groups[tc.class] = {
                                className: tc.class,
                                testcases: [],
                                passed: 0, failed: 0, errored: 0, skipped: 0, warning: 0, deprecation: 0, incomplete: 0,
                                hasIssues: false
                            };
                        }
                        const group = groups[tc.class];
                        group.testcases.push(tc);
                        const status = tc.status || 'passed'; // Default to passed if status is null/undefined
                        if (group[status] !== undefined) {
                            group[status]++;
                        }
                        // Count warnings and deprecations separately (they don't change the test status)
                        if (tc.warnings?.length > 0) {
                            group.warning += tc.warnings.length;
                            group.hasIssues = true;
                        }
                        if (tc.deprecations?.length > 0) {
                            group.deprecation += tc.deprecations.length;
                            group.hasIssues = true;
                        }
                        if (status !== 'passed') {
                            group.hasIssues = true;
                        }
                    });
                });

                const sortedGroups = Object.values(groups).sort((a, b) => {
                    if (a.hasIssues && !b.hasIssues) return -1;
                    if (!a.hasIssues && b.hasIssues) return 1;
                    return a.className.localeCompare(b.className);
                });

                sortedGroups.forEach(group => {
                    group.testcases.sort((a, b) => {
                        const statusOrder = { 'failed': 1, 'errored': 2, 'warning': 3, 'deprecation': 4, 'skipped': 5, 'incomplete': 6, 'passed': 7 };
                        const statusA = statusOrder[a.status || 'passed'] || 99;
                        const statusB = statusOrder[b.status || 'passed'] || 99;
                        if (statusA !== statusB) {
                            return statusA - statusB;
                        }
                        return a.name.localeCompare(b.name);
                    });
                });

                return sortedGroups;
            });

            const runTests = async (runOptions = {}) => {
                activeTab.value = 'results'; // Ensure results tab is active
                const endpoint = runOptions.endpoint || '/api/run';
                const payload = {
                    filters: runOptions.filters || [],
                    groups: selectedGroups.value,
                    suites: selectedSuites.value,
                    options: { ...options, colors: true },
                    contextId: runOptions.contextId,
                };
                try {
                    const response = await fetch(endpoint, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error(`Error starting test run: ${errorData.error}`);
                        updateFavicon('failure');
                    }
                } catch (error) {
                    console.error(`API request failed: ${error.message}`);
                    updateFavicon('failure');
                }
            };

            onMounted(() => {
                connectWebSocket();
                fetchTests();
                updateFavicon();
                const resizer = document.getElementById('resizer');
                const sidebar = document.getElementById('test-sidebar');
                if (resizer && sidebar) {
                    let isResizing = false;
                    resizer.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        isResizing = true;
                        document.body.style.cursor = 'col-resize';
                        document.body.style.userSelect = 'none';
                        const mouseMoveHandler = (e) => {
                            if (!isResizing) return;
                            const sidebarWidth = e.clientX;
                            if (sidebarWidth > 200 && sidebarWidth < window.innerWidth - 200) {
                                sidebar.style.width = `${sidebarWidth}px`;
                            }
                        };
                        const mouseUpHandler = () => {
                            isResizing = false;
                            document.body.style.cursor = '';
                            document.body.style.userSelect = '';
                            document.removeEventListener('mousemove', mouseMoveHandler);
                            document.removeEventListener('mouseup', mouseUpHandler);
                        };
                        document.addEventListener('mousemove', mouseMoveHandler);
                        document.addEventListener('mouseup', mouseUpHandler);
                    });
                }
            });

            return {
                runningTestIds, stopPending, isAnyTestRunning, isAnyStopPending,
                activeTab, results, searchQuery, testSuites, availableSuites, selectedSuites, availableGroups, selectedGroups, options,
                showFilterPanel, expandedSuites, expandedTestId, hasFailedTests,
                runAllTests, runFailedTests, toggleSuite, runSingleTest, runSuiteTests, filteredTestSuites, toggleFilterPanel, toggleDetails, isExpanded,
                statusCounts,
                stopTests, togglePlayStop, stopSingleTest, isTestRunning, isTestStopPending,
                groupedResults, expandedTestcaseGroups, toggleTestcaseGroup, statusClass
            };
        }
    }).mount('#app');
</script>
</body>
</html>